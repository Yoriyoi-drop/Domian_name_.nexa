name: MyProject.nexa CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: myproject-nexa-backend
  ECR_REPOSITORY_FRONTEND: myproject-nexa-frontend
  KUBE_CONFIG_PATH: ${{ secrets.KUBE_CONFIG_PATH }}

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 21
      uses: actions/setup-java@v3
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Run backend tests
      run: |
        cd backend
        ./mvnw test
        ./mvnw jacoco:report
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        file: ./backend/target/site/jacoco/jacoco.xml
        flags: backend
        name: backend

  test-frontend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        
    - name: Cache node modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm run test:coverage
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        file: ./frontend/coverage/lcov.info
        flags: frontend
        name: frontend

  security-scan:
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    steps:
    - uses: actions/checkout@v3
    
    # Run OWASP Dependency Check on backend
    - name: OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'MyProject.nexa Backend'
        scanPath: './backend'
        format: 'ALL'
        out: 'reports'
        args: >
          --enableRetired
          --failOnCVSS 7
          
    - name: Upload Security Report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: reports/

  build-and-push:
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    - name: Build and push backend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build backend Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG -f Dockerfile.backend .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
        
    - name: Build and push frontend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build frontend Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG -f Dockerfile.frontend .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name myproject-nexa-staging --region ${{ env.AWS_REGION }}
        
    - name: Deploy to staging
      run: |
        # Update image tags in Kubernetes manifests
        sed -i "s|myproject-nexa-backend:latest|${{ secrets.ECR_REGISTRY }}/myproject-nexa-backend:${{ github.sha }}|g" kubernetes/deployment.yaml
        sed -i "s|myproject-nexa-frontend:latest|${{ secrets.ECR_REGISTRY }}/myproject-nexa-frontend:${{ github.sha }}|g" kubernetes/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f kubernetes/ -n myproject-nexa

  deploy-production:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name myproject-nexa-production --region ${{ env.AWS_REGION }}
        
    - name: Deploy to production using blue-green strategy
      run: |
        # Get current active deployment (blue or green)
        CURRENT_ACTIVE=$(kubectl get service myproject-nexa-backend-svc-blue-green -n myproject-nexa -o jsonpath='{.spec.selector.version}')
        
        # If current is blue, deploy green; if current is green, deploy blue
        if [ "$CURRENT_ACTIVE" = "blue" ]; then
          NEW_VERSION="green"
          OLD_VERSION="blue"
        else
          NEW_VERSION="blue"
          OLD_VERSION="green"
        fi
        
        # Update the new deployment with the new image
        kubectl set image deployment/myproject-nexa-backend-$NEW_VERSION -n myproject-nexa backend=${{ secrets.ECR_REGISTRY }}/myproject-nexa-backend:${{ github.sha }}
        
        # Wait for the new deployment to be ready
        kubectl rollout status deployment/myproject-nexa-backend-$NEW_VERSION -n myproject-nexa
        
        # Update the service to point to the new deployment
        kubectl patch service myproject-nexa-backend-svc-blue-green -n myproject-nexa -p '{"spec":{"selector":{"version":"'"$NEW_VERSION"'"}}}'
        
        # Scale down the old deployment
        kubectl scale deployment/myproject-nexa-backend-$OLD_VERSION -n myproject-nexa --replicas=0
        
        # Verify deployment
        kubectl get pods -n myproject-nexa